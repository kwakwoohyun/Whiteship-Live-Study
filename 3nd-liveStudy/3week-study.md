# 3주차 과제: 연산자 

## > 목표 :
#### 자바가 제공하는 다양한 연산자를 학습하세요.
## > 학습할것 : 
- 산술 연산자
- 비트 연산자
- 관계 연산자
- 논리 연산자
- instanceof
- assignment(=) operator
- 화살표(->) 연산자
- 3항 연산자
- 연산자 우선 순위
- (optional) Java 13. switch 연산자 
------------
> 산술 연산자

- 산술 연산자는 덧셈, 뺄셈 등 산술 연산을 수행하는 연산자이다.
- 산술 연산자(Arithmetic Operators)는 정수, 부동소수점, 문자열 등 boolean 타입을 제외한 모든 Primitive Type에서 사용이 가능하다.

![산술연산](https://t1.daumcdn.net/cfile/tistory/9994BF335A156E6B22 "출처 https://keep-cool.tistory.com/18")

- 더하기(`+`)
    - 기본적으로 두 수를 더하는 연산이지만 문자열을 연결시키는데도 사용할 수 있다.
    - 만약 `+`의 피연산자 중 문자열이 있다면 다른 피연산자도 문자열로 변환된다.
- 빼기(`-`)
    - `-`연산자는 첫번째 피연산자에서 두번째 피연산자를 빼는 연산자이다. 
    - 다만 더하기 연산 처럼 문자열 연산은 불가하다.
- 곱하기(`*`)
    - `*`연산자는 두 피연산자를 곱한다.
    - 빼기 연산과 마찬가지로 문자열 연산은 불가하다.
- 나누기(`/`)
    - `/`연산자는 첫번째 피연산자를 두번째 피연산자로 나눈다.
    - 두 피연산자가 모두 정수라면 결과도 정수이며 나머지는 내림으로 없어지고, 피연산자 중 부동소수점이 있다면 결과도 부동소수점 입니다.
    - 정수를 0으로 나누면 `ArithmeticException`이 발생 한다.
- 나머지(`%`)
    - `%` 연산자는 첫번째 피연산자를 두번째 피연산자로 나누고 남은 나머지를 정수로 리턴 한다.
    - 정수로 연산할 때 0으로 연산하면 나누기와 마찬가지로 `ArithmeticException`이 발생 한다.
    - 부동소수점을 연산할 때 0으로 연산한다면 `NaN` 평가가 된다.
-----------------
> 비트 연산자

- 비트 연산자(Bitwise Operators) 및 시프트 연산자(Shift Operators)는 개별 비트를 조작하는 저수준(low-level) 연산자 이다.
- 비트 연산을 이해하기 위해서는 이진수와 음의 정수를 나타내는 데 사용되는 2의 보수를 이해해야 한다.
- 비트 연산자는 논리 연산자와 비슷하지만, 비트(bit) 단위로 논리 연산을 할 때 사용하는 연산자이다.
- 비트 단위로 왼쪽이나 오른쪽으로 전체 비트를 이동하거나, 1의 보수를 만들 때도 사용된다.
- 종류

| 비트 연산자 | 설명 |
|:----------:|:-----------|
| `&` | 비트 AND(`&`) 연산자로 양쪽 비트가 모두 1일때만 결과가 1이되고 그렇지 않으면 0이 된다. | 
| `|` | 비트 OR(`|`) 연산자로 양쪽 비트 중 어느 하나라도 1이면 결과가 1이되고 모두 0일때만 0이 된다. |
| `^` | 비트 XOR(`^`) 연산자로 양쪽 비트가 서로 다를때만 1이되고 같을때는 0이 된다. |
| `~` | 비트 NOT(`~`) 연산자로 비트 반전자로 각 비트를 반전시켜 1을 0으로, 0을 1로 변환한다. |
| `<<` | 좌측 쉬프트 연산자(`<<`)는 왼편에 있는 피연산자의 비트 값을 연산자 오른편에 지정한 수만큼 왼쪽으로 이동, 오른쪽 남은 비트는 0으로 채운다. |
| `>>` | 우측 쉬프트 연산자(`>>`)는 왼편에 있는 피연산자의 비트 값을 연산자 오른편에 지정한 수만큼 오른쪽으로 이동, 비어있는 왼쪽 비트는 부호와 같은 값으로 채운다. |
| `>>>` | unsigned 우측 쉬프트 연산자(`>>>`)는 왼편의 남은 비트를 부호와는 무관하게 0으로 채운다. |
----------
> 관계 연산자

- 같거나 같지 않음을 평가하는 비교 연산자(Comparison Operators)
- 크고 작은 관계를 평가하는 관계 연산자(Relational Operators)
- `boolean` 결과를 도출 하므로 조건문(`if`) 이나 반복문 (`for`, `while`) 등에서 결정을 위해 사용

| 관계 연산자 | 설명 |
|:----------:|:-----------|
| Equals(`==`) | `==` 연산자는 Primitive Type를 비교할 때 두 피연산자의 값이 같다면 `true`를 그렇지 않다면 `false`를 리턴 한다.<br/>`String` 이나 `참조타입`의 피연산자를 비교하면 동일한 객체 인지 여부를 체크한다. | 
| Not Equals (`!=`) | `!=` 연산자는 `==` 연산자와 정반대로 두 피연산자의 값이 다른지 여부를 체크하여 `true`/`false`를 리턴 한다.<br/>`String` 이나 `참조타입`일 경우엔 동일한 객체 인지 여부를 체크합니다. |
| 작음 (`<`), 작거나 같음 (`<=`) | 첫번째 피연산자가 두번째 피연산자보다 작은지 여부를 평가(Evaluate)하려면 `<` 연산자를 사용하고, 같은지 여부까지 평가하려면 `<=` 연산자를 사용한다. |
| 큼 (`>`), 크거나 같음 (`>=`) | 위 연산자와 정반대로 첫번째 피연산자가 두번째 피연산자보다 큰지 여부를 평가하기 위해 `>` 연산자를 사용하고, 같음 여부도 평가하려면 `>=` 연산자를 사용한다. |
-------
> 논리 연산자

- Boolean Operators 라고도 하며 관계 연산자와 동일하게 true/false 결과를 리턴 한다.
- 여러 비교 연산을 사용하여 복잡도를 높인 조건식을 만들 때 주로 사용 된다. 

| 논리 연산자 | 설명 |
|:----------:|:-----------|
| 조건부 AND (`&&`) | 두 피연산자가 모두 `true`인지 여부를 평가하며 두 피연산자 중 하나라도 `false`라면 `false`를 리턴 한다. | 
| 조건부 OR (`||`) | 두 피연산자 중 하나라도 `true`라면 `true`를 리턴 한다.|
| 부정 연산자 (`!`) | 단항 연산자로써 해당 값의 결과의 반대로 평가 한다. |
-------
> instanceof

- 객체(Object) 또는 배열(Array) 값을 어떠한 참조 유형에 맞는 값인지를 평가하는 연산자 이다.
- 만약 null을 평가한다면 항상 false가 리턴 된다.
- 만약 평가 결과가 true라면 비교된 참조 유형으로 안전하게 캐스팅하고 할당할 수 있다는 것을 의미한다.
- 참조 변수가 instanceof로 형 변환 가능한 타입인지 연산한다. 형 변환이 가능하다면 `true`로 반환,
가능하지 못한다면 `false`로 반환한다.

`B b = new B();`<br/>
`if (b instanceof Object) {`<br/>
    `System.out.println("형변환 가능");`<br/>
    `}`

-----------
> assignment(=) operator

- 대입 연산자 (Assignment Operator)
- 어떠한 변수에 값을 할당할 때 이 연산자를 사용할 수 있으며 메모리에 값을 저장하거나 할당한다는 의미 이다.
- 수학에서 `=`는 '왼쪽값과 오른쪽값이 같다.'이지만 프로그램에서는 '오른쪽 값을 왼쪽에 대입한다.'라는 의미이다.  
- `int i = 10;`
-  `i`변수에 10 을 할당할 수 있다.
--------
> 화살표(->) 연산자

- 화살표 연산자 (Lamda Expression : ->)
- Java 8 부터 도입된 연산자로 람다 표현식(Lamda Expression) 이라고 하며 메소드 본문에 해당 실행 가능한 자바 코드의 익명 컬렉션이다.
- 람다 함수는 프로그래밍 언어에서 사용되는 개념으로 익명 함수(Anonymous functions)를 지칭하는 용어이다.
- 람다식이란 "식별자없이 실행가능한 함수", 함수인데 함수를 따로 만들지 않고 코드한줄에 함수를 써서 그것을 호출하는 방식이다.
- `(매개변수, ...) -> { 실행문 ... }`
- `(매개변수, ...)`는 오른쪽 중괄호 `{ }` 블록을 실행하기 위해 필요한 값을 제공하는 역할을 합니다. 매개 변수의 이름은 개발자가 자유롭게 지정할 수 있으며 인자타입도 명시하지 않아도 된다. `->` 기호는 매개 변수를 이용해서 중괄호 `{ }` 바디를 실행한다는 뜻으로 해석하면 된다.
- 장점 
    - 코드를 간결하게 만들 수 있다.
    - 코드가 간결하고 식에 개발자의 의도가 명확히 드러나므로 가독성이 향상된다.
    - 함수를 만드는 과정없이 한번에 처리할 수 있기에 코딩하는 시간이 줄어든다.
    - 병렬프로그래밍이 용이하다.
- 단점
    - 람다를 사용하면서 만드는 무명함수는 재사용이 불가능하다.
    - 디버깅이 다소 까다롭다.
    - 람다를 남발하면 코드가 지저분해질 수 있다. (비슷한 함수를 계속 중복생성할 가능성이 높음)
    - 재귀로 만들경우에는 다소 부적합한면이 있다.

```
public interface Ramda {
    public void justOne( int a, int b );
}
```
```
Ramda ramda = ( int a, int b ) -> {
    System.out.println(a + b);
};

    ramda.justOne(2, 3);
```
- 만약 인터페이스가 하나의 매개변수만 있다면 ()도 생략 가능하다.
```
public interface Ramda {
    public void justOne( int a );
}
```
```
Ramda ramda = a -> {
    System.out.println(a);
};
```
- 만약 하나의 실행문만 존재한다면 중괄호 {}도 생략 가능하다.
```
Ramda ramda = a ->  System.out.println(a);
```
-----------
> 3항 연산자

- 3항 연산자 (Conditional Operator : `? :`)
- 3항 연산자는 C언어로 부터 차용한 연산자 있다.
- `if` ~ `else` 문장을 연산자로 표현할 수 있고 조건에 따라 결과를 반환할 수 있다.
- 조건 ? `true일때 결과` : `false 일때 결과`
- `x > y ? x : y;` -> x가 y보다 크면 x 작으면 y
------------
> 연산자 우선 순위

| 순위 | 연산자 | 내용 |
|:----------:|:----------:|:-----------|
| 1 | `.` | 객체 멤버 접근 | 
| 1 | `[]` | 배열 요소 접근 | 
| 1 | `(args)` | 메소드 호출 | 
| 1 | `data++`, `data--` | 후위 증감 | 
| 2 | `++data`, `--data` | 전위 증감 | 
| 2 | `+`, `-` | 단항 증감 | 
| 2 | `~`, `!` | 비트 보수, 부정 연산 | 
| 3 | `new` | 객체 생성 | 
| 3 | `(type)` | 캐스팅 | 
| 4 | `*`, `/`, `%` | 곱하기, 나누기, 나머지 | 
| 5 | `+`, `-` | 더하기, 빼기 |
| 6 | `<<`, `>>`, `>>>` | 왼쪽 시프트, 오른쪽 시프트, 부호없는 오른쪽 시프트 |
| 7 | `<`, `<=`, `>`, `>=` | 작음, 작거나 같음, 큼, 크거나 같음 |
| 7 | `instanceof` | 타입 비교 |
| 8 | `==`, `!=` | 같음, 같지 않음 | 
| 9 | `&` | AND |
| 10 | `^` | XOR |
| 11 | `|` | OR |
| 12 | `&&` | AND |
| 13 | `||` | OR |
| 14 | `? :` | 3항 연산자 |
| 15 | `=`, `*=`, `/=`, `%=`, `+=`, `-=`, `<<=`, `>>=`, `>>>=`, `&=`, `^=`, `!=` | 대입 연산자 |
| 16 | `->` | 람다 표현식 |
--------------

